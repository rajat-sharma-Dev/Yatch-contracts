'use strict';

function is(x) {
    return typeof x === "bigint";
}
function compare(x, y) {
    return Number(x - y);
}
function abs(x) {
    return x < 0n ? -x : x;
}
function sign(x) {
    return x < 0n ? -1n : (x > 0n ? 1n : 0n);
}
function floorDiv(x, y) {
    if (y < 0n) {
        x = -x;
        y = -y;
    }
    return x >= 0n ? x / y : (x - y + 1n) / y;
}
function ceilDiv(x, y) {
    if (y < 0n) {
        x = -x;
        y = -y;
    }
    return x >= 0n ? (x + y - 1n) / y : x / y;
}
function roundDiv(x, y) {
    if (y < 0n) {
        x = -x;
        y = -y;
    }
    return x >= 0n ? (x + y / 2n) / y : (x - y / 2n) / y;
}
function rem(x, y) {
    return x % y;
}
function mod(x, y) {
    return x - y * floorDiv(x, y);
}
function modp(x, y) {
    return x - abs(y) * floorDiv(x, abs(y));
}
function constrain(x, minv, maxv) {
    return min(max(x, minv), maxv);
}
function remap(x, r, R, t, T) {
    return t + (x - r) * (T - t) / (R - r);
}
function lerp(x, y, t) {
    return x + BigInt(Math.floor(t * Number(y - x)));
}
function isPow2(x) {
    return /^10*$/.test(x.toString(2));
}
function isPow10(x) {
    return /^10*$/.test(x.toString());
}
function prevPow2(x) {
    if (x <= 1n)
        return 0n;
    var n = x.toString(2).length;
    return BigInt("0b1" + "0".repeat(n - 1));
}
function prevPow10(x) {
    if (x <= 1n)
        return 0n;
    var n = x.toString(10).length;
    return BigInt("1" + "0".repeat(n - 1));
}
function nextPow2(x) {
    if (x <= 0n)
        return 1n;
    var n = (x - 1n).toString(2).length;
    return BigInt("0b1" + "0".repeat(n));
}
function nextPow10(x) {
    if (x <= 0n)
        return 1n;
    var n = (x - 1n).toString(10).length;
    return BigInt("1" + "0".repeat(n));
}
function log2(x) {
    var n = x.toString(2).length - 1;
    return x <= 0n ? 0n : BigInt(n);
}
function log10(x) {
    var n = x.toString().length - 1;
    return x <= 0n ? 0n : BigInt(n);
}
function sqrt(x) {
    if (x === 0n)
        return 0n;
    return x > 0n ? sqrtPos(x) : null;
}
function sqrtPos(x) {
    var a = 1n << (log2(x) / 2n + 1n);
    var b = 1n + a;
    while (a < b) {
        b = a;
        a = (b + x / b) / 2n;
    }
    return b;
}
function cbrt(x) {
    return root(x, 3n);
}
function root(x, n = 1n) {
    if (x === 0n)
        return 0n;
    else if (x > 0n)
        return rootPos(x, n);
    return n % 2n !== 0n ? -rootPos(-x, n) : null;
}
function rootPos(x, n) {
    var a = 1n << (log2(x) / n + 1n);
    var b = 1n + a, m = n - 1n;
    if (a === 2n)
        return 1n;
    while (a < b) {
        b = a;
        a = (m * b + x / b ** m) / n;
    }
    return b;
}
function properDivisors(x) {
    var x = abs(x), a = [];
    for (var i = 1n; i < x; i++)
        if (x % i === 0n)
            a.push(i);
    return a;
}
function aliquotSum(x) {
    var x = abs(x), a = 0n;
    for (var i = 1n; i < x; i++)
        if (x % i === 0n)
            a += i;
    return a;
}
function minPrimeFactor(x) {
    var x = abs(x);
    if (x <= 1n)
        return 0n;
    if (x <= 3n)
        return x;
    if (x % 2n === 0n)
        return 2n;
    if (x % 3n === 0n)
        return 3n;
    for (var i = 6n, I = sqrt(x) + 1n; i <= I; i += 6n) {
        if (x % (i - 1n) === 0n)
            return i - 1n;
        if (x % (i + 1n) === 0n)
            return i + 1n;
    }
    return x;
}
function maxPrimeFactor(x) {
    var x = abs(x), a = 0n;
    if (x <= 1n)
        return 0n;
    if (x <= 3n)
        return x;
    for (; x % 2n === 0n; a = 2n)
        x /= 2n;
    for (; x % 3n === 0n; a = 3n)
        x /= 3n;
    for (var i = 6n, I = sqrt(x) + 1n; x > 1n && i <= I; i += 6n) {
        for (; x % (i - 1n) == 0n; a = i - 1n)
            x /= i - 1n;
        for (; x % (i + 1n) == 0n; a = i + 1n)
            x /= i + 1n;
    }
    if (x <= 1n)
        return a;
    return x;
}
function primeFactors(x) {
    var x = abs(x), a = [];
    if (x <= 1n)
        return [];
    if (x <= 3n)
        return [x];
    x = pushPrimeFactorTo$(a, x, 2n);
    x = pushPrimeFactorTo$(a, x, 3n);
    for (var i = 6n, I = sqrt(x) + 1n; x > 1n && i <= I; i += 6n) {
        x = pushPrimeFactorTo$(a, x, i - 1n);
        x = pushPrimeFactorTo$(a, x, i + 1n);
    }
    if (x > 1n)
        a.push(x);
    return a;
}
function pushPrimeFactorTo$(a, x, f) {
    if (x % f !== 0n)
        return x;
    do {
        x /= f;
    } while (x % f === 0n);
    a.push(f);
    return x;
}
function primeExponentials(x) {
    var x = abs(x), a = [];
    if (x <= 1n)
        return [];
    if (x <= 3n)
        return [[x, 1n]];
    x = pushPrimeExponentialTo$(a, x, 2n);
    x = pushPrimeExponentialTo$(a, x, 3n);
    for (var i = 6n, I = sqrt(x) + 1n; x > 1n && i <= I; i += 6n) {
        x = pushPrimeExponentialTo$(a, x, i - 1n);
        x = pushPrimeExponentialTo$(a, x, i + 1n);
    }
    if (x > 1n)
        a.push([x, 1n]);
    return a;
}
function pushPrimeExponentialTo$(a, x, f) {
    if (x % f !== 0n)
        return x;
    var e = 0n;
    do {
        x /= f;
        ++e;
    } while (x % f === 0n);
    a.push([f, e]);
    return x;
}
function isPrime(x) {
    return x !== 0n && minPrimeFactor(x) === abs(x);
}
function gcd(...xs) {
    var a = xs[0] || 1n;
    for (var i = 1, I = xs.length; i < I; i++)
        a = gcdPair(a, xs[i]);
    return a;
}
function gcdPair(x, y) {
    while (y !== 0n) {
        var t = y;
        y = x % y;
        x = t;
    }
    return x;
}
function lcm(...xs) {
    var a = xs[0] || 1n;
    for (var i = 1, I = xs.length; i < I; i++)
        a = a * xs[i] / gcdPair(a, xs[i]);
    return a;
}
function factorial(n, k = 0n) {
    if (n < 0n)
        return 0n;
    for (var i = k + 1n, a = 1n; i <= n; i++)
        a *= i;
    return a;
}
function binomial(n, k) {
    if (k < 0n || k > abs(n))
        return 0n;
    if (n < 0n)
        return ((-1n) ** k) * binomial(-n, k);
    k = k > n - k ? n - k : k;
    for (var a = 1n, b = 1n, i = 1n; i <= k; i++, n--) {
        a *= n;
        b *= i;
    }
    return a / b;
}
function multinomial(...ks) {
    var n = sum(...ks), a = 1n, b = 1n;
    for (var i = 0, j = 0n, I = ks.length; i < I;) {
        if (j <= 0n)
            j = ks[i++];
        else {
            a *= n--;
            b *= j--;
        }
    }
    return a / b;
}
function hypot(...xs) {
    var a = 0n;
    for (var x of xs)
        a += x * x;
    return sqrt(a);
}
function sum(...xs) {
    var a = 0n;
    for (var x of xs)
        a += x;
    return a;
}
function product(...xs) {
    var a = 1n;
    for (var x of xs)
        a *= x;
    return a;
}
function median(...xs) {
    if (xs.length === 0)
        return 0n;
    xs.sort(compare);
    var i = xs.length >> 1;
    if ((xs.length & 1) === 1)
        return xs[i];
    return (xs[i - 1] + xs[i]) / 2n;
}
function modes(...xs) {
    xs.sort(compare);
    var r = maxRepeat(xs);
    return getRepeats(xs, r);
}
function maxRepeat(xs) {
    var count = Math.min(xs.length, 1), max = count;
    for (var i = 1, I = xs.length; i < I; i++) {
        if (xs[i - 1] === xs[i])
            count++;
        else {
            max = Math.max(max, count);
            count = 1;
        }
    }
    return Math.max(max, count);
}
function getRepeats(xs, r) {
    var a = [];
    r--;
    for (var i = 0, I = xs.length - r; i < I; i++)
        if (xs[i] === xs[i + r])
            a.push(xs[i += r]);
    return a;
}
function min(...xs) {
    if (xs.length === 0)
        return 0n;
    var a = xs[0];
    for (var x of xs)
        a = x < a ? x : a;
    return a;
}
function max(...xs) {
    if (xs.length === 0)
        return 0n;
    var a = xs[0];
    for (var x of xs)
        a = x > a ? x : a;
    return a;
}
function range(...xs) {
    if (xs.length === 0)
        return [0n, 0n];
    var a = xs[0], b = a;
    for (var x of xs) {
        a = x < a ? x : a;
        b = x > b ? x : b;
    }
    return [a, b];
}
function variance(...xs) {
    if (xs.length === 0)
        return 0n;
    var m = arithmeticMean(...xs), a = 0n;
    for (var x of xs)
        a += (x - m) ** 2n;
    return a / BigInt(xs.length);
}
function arithmeticMean(...xs) {
    var n = BigInt(xs.length);
    return sum(...xs) / n;
}
function geometricMean(...xs) {
    var n = BigInt(xs.length);
    return root(product(...xs), n);
}
function harmonicMean(...xs) {
    var n = BigInt(xs.length);
    var p = product(...xs), q = 0n;
    for (var x of xs)
        q += p / x;
    return n * p / q;
}
function quadriaticMean(...xs) {
    var n = BigInt(xs.length);
    var a = 0n;
    for (var x of xs)
        a += x * x;
    return sqrt(a / n);
}
function cubicMean(...xs) {
    var n = BigInt(xs.length);
    var a = 0n;
    for (var x of xs)
        a += x ** 3n;
    return cbrt(a / n);
}

exports.abs = abs;
exports.aliquotParts = properDivisors;
exports.aliquotSum = aliquotSum;
exports.arithmeticMean = arithmeticMean;
exports.binomial = binomial;
exports.cbrt = cbrt;
exports.ceilDiv = ceilDiv;
exports.clamp = constrain;
exports.compare = compare;
exports.constrain = constrain;
exports.cubicMean = cubicMean;
exports.factorial = factorial;
exports.floorDiv = floorDiv;
exports.gcd = gcd;
exports.geometricMean = geometricMean;
exports.greatestPrimeFactor = maxPrimeFactor;
exports.harmonicMean = harmonicMean;
exports.hcf = gcd;
exports.hypot = hypot;
exports.is = is;
exports.isPow10 = isPow10;
exports.isPow2 = isPow2;
exports.isPrime = isPrime;
exports.lcm = lcm;
exports.leastPrimeFactor = minPrimeFactor;
exports.lerp = lerp;
exports.log10 = log10;
exports.log2 = log2;
exports.map = remap;
exports.max = max;
exports.maxPrimeFactor = maxPrimeFactor;
exports.mean = arithmeticMean;
exports.median = median;
exports.min = min;
exports.minPrimeFactor = minPrimeFactor;
exports.mod = mod;
exports.modes = modes;
exports.modp = modp;
exports.multinomial = multinomial;
exports.nextPow10 = nextPow10;
exports.nextPow2 = nextPow2;
exports.prevPow10 = prevPow10;
exports.prevPow2 = prevPow2;
exports.primeExponentials = primeExponentials;
exports.primeFactors = primeFactors;
exports.product = product;
exports.properDivisors = properDivisors;
exports.quadriaticMean = quadriaticMean;
exports.range = range;
exports.rem = rem;
exports.remap = remap;
exports.root = root;
exports.rootMeanSquare = quadriaticMean;
exports.roundDiv = roundDiv;
exports.sign = sign;
exports.sqrt = sqrt;
exports.sum = sum;
exports.variance = variance;
