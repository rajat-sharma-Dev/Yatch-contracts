function is(x) {
    return typeof x === "bigint";
}
function compare(x, y) {
    return Number(x - y);
}
function abs(x) {
    return x < 0n ? -x : x;
}
function sign(x) {
    return x < 0n ? -1n : (x > 0n ? 1n : 0n);
}
function floorDiv(x, y) {
    if (y < 0n) {
        x = -x;
        y = -y;
    }
    return x >= 0n ? x / y : (x - y + 1n) / y;
}
function ceilDiv(x, y) {
    if (y < 0n) {
        x = -x;
        y = -y;
    }
    return x >= 0n ? (x + y - 1n) / y : x / y;
}
function roundDiv(x, y) {
    if (y < 0n) {
        x = -x;
        y = -y;
    }
    return x >= 0n ? (x + y / 2n) / y : (x - y / 2n) / y;
}
function rem(x, y) {
    return x % y;
}
function mod(x, y) {
    return x - y * floorDiv(x, y);
}
function modp(x, y) {
    return x - abs(y) * floorDiv(x, abs(y));
}
function constrain(x, minv, maxv) {
    return min(max(x, minv), maxv);
}
function remap(x, r, R, t, T) {
    return t + (x - r) * (T - t) / (R - r);
}
function lerp(x, y, t) {
    return x + BigInt(Math.floor(t * Number(y - x)));
}
function isPow2(x) {
    return /^10*$/.test(x.toString(2));
}
function isPow10(x) {
    return /^10*$/.test(x.toString());
}
function prevPow2(x) {
    if (x <= 1n)
        return 0n;
    var n = x.toString(2).length;
    return BigInt("0b1" + "0".repeat(n - 1));
}
function prevPow10(x) {
    if (x <= 1n)
        return 0n;
    var n = x.toString(10).length;
    return BigInt("1" + "0".repeat(n - 1));
}
function nextPow2(x) {
    if (x <= 0n)
        return 1n;
    var n = (x - 1n).toString(2).length;
    return BigInt("0b1" + "0".repeat(n));
}
function nextPow10(x) {
    if (x <= 0n)
        return 1n;
    var n = (x - 1n).toString(10).length;
    return BigInt("1" + "0".repeat(n));
}
function log2(x) {
    var n = x.toString(2).length - 1;
    return x <= 0n ? 0n : BigInt(n);
}
function log10(x) {
    var n = x.toString().length - 1;
    return x <= 0n ? 0n : BigInt(n);
}
function sqrt(x) {
    if (x === 0n)
        return 0n;
    return x > 0n ? sqrtPos(x) : null;
}
function sqrtPos(x) {
    var a = 1n << (log2(x) / 2n + 1n);
    var b = 1n + a;
    while (a < b) {
        b = a;
        a = (b + x / b) / 2n;
    }
    return b;
}
function cbrt(x) {
    return root(x, 3n);
}
function root(x, n = 1n) {
    if (x === 0n)
        return 0n;
    else if (x > 0n)
        return rootPos(x, n);
    return n % 2n !== 0n ? -rootPos(-x, n) : null;
}
function rootPos(x, n) {
    var a = 1n << (log2(x) / n + 1n);
    var b = 1n + a, m = n - 1n;
    if (a === 2n)
        return 1n;
    while (a < b) {
        b = a;
        a = (m * b + x / b ** m) / n;
    }
    return b;
}
function properDivisors(x) {
    var x = abs(x), a = [];
    for (var i = 1n; i < x; i++)
        if (x % i === 0n)
            a.push(i);
    return a;
}
function aliquotSum(x) {
    var x = abs(x), a = 0n;
    for (var i = 1n; i < x; i++)
        if (x % i === 0n)
            a += i;
    return a;
}
function minPrimeFactor(x) {
    var x = abs(x);
    if (x <= 1n)
        return 0n;
    if (x <= 3n)
        return x;
    if (x % 2n === 0n)
        return 2n;
    if (x % 3n === 0n)
        return 3n;
    for (var i = 6n, I = sqrt(x) + 1n; i <= I; i += 6n) {
        if (x % (i - 1n) === 0n)
            return i - 1n;
        if (x % (i + 1n) === 0n)
            return i + 1n;
    }
    return x;
}
function maxPrimeFactor(x) {
    var x = abs(x), a = 0n;
    if (x <= 1n)
        return 0n;
    if (x <= 3n)
        return x;
    for (; x % 2n === 0n; a = 2n)
        x /= 2n;
    for (; x % 3n === 0n; a = 3n)
        x /= 3n;
    for (var i = 6n, I = sqrt(x) + 1n; x > 1n && i <= I; i += 6n) {
        for (; x % (i - 1n) == 0n; a = i - 1n)
            x /= i - 1n;
        for (; x % (i + 1n) == 0n; a = i + 1n)
            x /= i + 1n;
    }
    if (x <= 1n)
        return a;
    return x;
}
function primeFactors(x) {
    var x = abs(x), a = [];
    if (x <= 1n)
        return [];
    if (x <= 3n)
        return [x];
    x = pushPrimeFactorTo$(a, x, 2n);
    x = pushPrimeFactorTo$(a, x, 3n);
    for (var i = 6n, I = sqrt(x) + 1n; x > 1n && i <= I; i += 6n) {
        x = pushPrimeFactorTo$(a, x, i - 1n);
        x = pushPrimeFactorTo$(a, x, i + 1n);
    }
    if (x > 1n)
        a.push(x);
    return a;
}
function pushPrimeFactorTo$(a, x, f) {
    if (x % f !== 0n)
        return x;
    do {
        x /= f;
    } while (x % f === 0n);
    a.push(f);
    return x;
}
function primeExponentials(x) {
    var x = abs(x), a = [];
    if (x <= 1n)
        return [];
    if (x <= 3n)
        return [[x, 1n]];
    x = pushPrimeExponentialTo$(a, x, 2n);
    x = pushPrimeExponentialTo$(a, x, 3n);
    for (var i = 6n, I = sqrt(x) + 1n; x > 1n && i <= I; i += 6n) {
        x = pushPrimeExponentialTo$(a, x, i - 1n);
        x = pushPrimeExponentialTo$(a, x, i + 1n);
    }
    if (x > 1n)
        a.push([x, 1n]);
    return a;
}
function pushPrimeExponentialTo$(a, x, f) {
    if (x % f !== 0n)
        return x;
    var e = 0n;
    do {
        x /= f;
        ++e;
    } while (x % f === 0n);
    a.push([f, e]);
    return x;
}
function isPrime(x) {
    return x !== 0n && minPrimeFactor(x) === abs(x);
}
function gcd(...xs) {
    var a = xs[0] || 1n;
    for (var i = 1, I = xs.length; i < I; i++)
        a = gcdPair(a, xs[i]);
    return a;
}
function gcdPair(x, y) {
    while (y !== 0n) {
        var t = y;
        y = x % y;
        x = t;
    }
    return x;
}
function lcm(...xs) {
    var a = xs[0] || 1n;
    for (var i = 1, I = xs.length; i < I; i++)
        a = a * xs[i] / gcdPair(a, xs[i]);
    return a;
}
function factorial(n, k = 0n) {
    if (n < 0n)
        return 0n;
    for (var i = k + 1n, a = 1n; i <= n; i++)
        a *= i;
    return a;
}
function binomial(n, k) {
    if (k < 0n || k > abs(n))
        return 0n;
    if (n < 0n)
        return ((-1n) ** k) * binomial(-n, k);
    k = k > n - k ? n - k : k;
    for (var a = 1n, b = 1n, i = 1n; i <= k; i++, n--) {
        a *= n;
        b *= i;
    }
    return a / b;
}
function multinomial(...ks) {
    var n = sum(...ks), a = 1n, b = 1n;
    for (var i = 0, j = 0n, I = ks.length; i < I;) {
        if (j <= 0n)
            j = ks[i++];
        else {
            a *= n--;
            b *= j--;
        }
    }
    return a / b;
}
function hypot(...xs) {
    var a = 0n;
    for (var x of xs)
        a += x * x;
    return sqrt(a);
}
function sum(...xs) {
    var a = 0n;
    for (var x of xs)
        a += x;
    return a;
}
function product(...xs) {
    var a = 1n;
    for (var x of xs)
        a *= x;
    return a;
}
function median(...xs) {
    if (xs.length === 0)
        return 0n;
    xs.sort(compare);
    var i = xs.length >> 1;
    if ((xs.length & 1) === 1)
        return xs[i];
    return (xs[i - 1] + xs[i]) / 2n;
}
function modes(...xs) {
    xs.sort(compare);
    var r = maxRepeat(xs);
    return getRepeats(xs, r);
}
function maxRepeat(xs) {
    var count = Math.min(xs.length, 1), max = count;
    for (var i = 1, I = xs.length; i < I; i++) {
        if (xs[i - 1] === xs[i])
            count++;
        else {
            max = Math.max(max, count);
            count = 1;
        }
    }
    return Math.max(max, count);
}
function getRepeats(xs, r) {
    var a = [];
    r--;
    for (var i = 0, I = xs.length - r; i < I; i++)
        if (xs[i] === xs[i + r])
            a.push(xs[i += r]);
    return a;
}
function min(...xs) {
    if (xs.length === 0)
        return 0n;
    var a = xs[0];
    for (var x of xs)
        a = x < a ? x : a;
    return a;
}
function max(...xs) {
    if (xs.length === 0)
        return 0n;
    var a = xs[0];
    for (var x of xs)
        a = x > a ? x : a;
    return a;
}
function range(...xs) {
    if (xs.length === 0)
        return [0n, 0n];
    var a = xs[0], b = a;
    for (var x of xs) {
        a = x < a ? x : a;
        b = x > b ? x : b;
    }
    return [a, b];
}
function variance(...xs) {
    if (xs.length === 0)
        return 0n;
    var m = arithmeticMean(...xs), a = 0n;
    for (var x of xs)
        a += (x - m) ** 2n;
    return a / BigInt(xs.length);
}
function arithmeticMean(...xs) {
    var n = BigInt(xs.length);
    return sum(...xs) / n;
}
function geometricMean(...xs) {
    var n = BigInt(xs.length);
    return root(product(...xs), n);
}
function harmonicMean(...xs) {
    var n = BigInt(xs.length);
    var p = product(...xs), q = 0n;
    for (var x of xs)
        q += p / x;
    return n * p / q;
}
function quadriaticMean(...xs) {
    var n = BigInt(xs.length);
    var a = 0n;
    for (var x of xs)
        a += x * x;
    return sqrt(a / n);
}
function cubicMean(...xs) {
    var n = BigInt(xs.length);
    var a = 0n;
    for (var x of xs)
        a += x ** 3n;
    return cbrt(a / n);
}

export { abs, properDivisors as aliquotParts, aliquotSum, arithmeticMean, binomial, cbrt, ceilDiv, constrain as clamp, compare, constrain, cubicMean, factorial, floorDiv, gcd, geometricMean, maxPrimeFactor as greatestPrimeFactor, harmonicMean, gcd as hcf, hypot, is, isPow10, isPow2, isPrime, lcm, minPrimeFactor as leastPrimeFactor, lerp, log10, log2, remap as map, max, maxPrimeFactor, arithmeticMean as mean, median, min, minPrimeFactor, mod, modes, modp, multinomial, nextPow10, nextPow2, prevPow10, prevPow2, primeExponentials, primeFactors, product, properDivisors, quadriaticMean, range, rem, remap, root, quadriaticMean as rootMeanSquare, roundDiv, sign, sqrt, sum, variance };
